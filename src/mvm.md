{%
typedef struct xtype *Xtype;
struct xtype {
	char *mvm_symbol;
};

#include "c.h"

#define SYMBOL_TABLE_BUCKETS 32

typedef struct td_list* TypedefList;
struct td_list {
	char *name;
	char *type;
	TypedefList link;
};

typedef List *OutputSymbolTable;

typedef void (*TypeVisitor)(Type t);

static void progbeg(int, char **);
static void function(Symbol, Symbol[], Symbol[], int);
static Node gen_with_typedefs(Node forest);

static int is_type_defined(Type);
static char *define_type(Type);
static char *define_function_signature(Symbol);
static char *unique_symbol(char *, OutputSymbolTable, int);
static void walk_type_tree(Node tree, TypeVisitor visitor);
static OutputSymbolTable osymtable_create(int);
static void osymtable_put(OutputSymbolTable, char *);
static int osymtable_check(OutputSymbolTable, char *);
static int osymtable_bucket(char *);

static List defined_types = NULL;
static TypedefList typedefs;
static OutputSymbolTable global_osymtable;
static OutputSymbolTable func_osymtable;
%}
/* Terminals generated for:
 * 8-bit char, 16-bit short, 32-bit int, 64-bit long, 64-bit long long*
 * 32-bit float, 64-bit double, 64-bit long double*, and 64-bit pointers**
 * *: this type is reportedly not used by the front end, but is included for
 *    futureproofing
 * **: for now, this is strictly an arbitrary choice...
 *
 * Opcodes were generated by the ops program in lcc/etc, which was apparently
 *  added when the code generation interface was redesigned
 * # ops c=1 s=2 i=4 l=8 h=8 f=4 d=8 x=8 p=8
 */
%start stmt
%term CNSTF4=4113 CNSTF8=8209
%term CNSTI1=1045 CNSTI2=2069 CNSTI4=4117 CNSTI8=8213
%term CNSTP8=8215
%term CNSTU1=1046 CNSTU2=2070 CNSTU4=4118 CNSTU8=8214
%term ARGB=41
%term ARGF4=4129 ARGF8=8225
%term ARGI4=4133 ARGI8=8229
%term ARGP8=8231
%term ARGU4=4134 ARGU8=8230
%term ASGNB=57
%term ASGNF4=4145 ASGNF8=8241
%term ASGNI1=1077 ASGNI2=2101 ASGNI4=4149 ASGNI8=8245
%term ASGNP8=8247
%term ASGNU1=1078 ASGNU2=2102 ASGNU4=4150 ASGNU8=8246
%term INDIRB=73
%term INDIRF4=4161 INDIRF8=8257
%term INDIRI1=1093 INDIRI2=2117 INDIRI4=4165 INDIRI8=8261
%term INDIRP8=8263
%term INDIRU1=1094 INDIRU2=2118 INDIRU4=4166 INDIRU8=8262
%term CVFF4=4209 CVFF8=8305
%term CVFI4=4213 CVFI8=8309
%term CVIF4=4225 CVIF8=8321
%term CVII1=1157 CVII2=2181 CVII4=4229 CVII8=8325
%term CVIU1=1158 CVIU2=2182 CVIU4=4230 CVIU8=8326
%term CVPU8=8342
%term CVUI1=1205 CVUI2=2229 CVUI4=4277 CVUI8=8373
%term CVUP8=8375
%term CVUU1=1206 CVUU2=2230 CVUU4=4278 CVUU8=8374
%term NEGF4=4289 NEGF8=8385
%term NEGI4=4293 NEGI8=8389
%term CALLB=217
%term CALLF4=4305 CALLF8=8401
%term CALLI4=4309 CALLI8=8405
%term CALLP8=8407
%term CALLU4=4310 CALLU8=8406
%term CALLV=216
%term RETF4=4337 RETF8=8433
%term RETI4=4341 RETI8=8437
%term RETP8=8439
%term RETU4=4342 RETU8=8438
%term RETV=248
%term ADDRGP8=8455
%term ADDRFP8=8471
%term ADDRLP8=8487
%term ADDF4=4401 ADDF8=8497
%term ADDI4=4405 ADDI8=8501
%term ADDP8=8503
%term ADDU4=4406 ADDU8=8502
%term SUBF4=4417 SUBF8=8513
%term SUBI4=4421 SUBI8=8517
%term SUBP8=8519
%term SUBU4=4422 SUBU8=8518
%term LSHI4=4437 LSHI8=8533
%term LSHU4=4438 LSHU8=8534
%term MODI4=4453 MODI8=8549
%term MODU4=4454 MODU8=8550
%term RSHI4=4469 RSHI8=8565
%term RSHU4=4470 RSHU8=8566
%term BANDI4=4485 BANDI8=8581
%term BANDU4=4486 BANDU8=8582
%term BCOMI4=4501 BCOMI8=8597
%term BCOMU4=4502 BCOMU8=8598
%term BORI4=4517 BORI8=8613
%term BORU4=4518 BORU8=8614
%term BXORI4=4533 BXORI8=8629
%term DIVF4=4545 DIVF8=8641
%term DIVI4=4549 DIVI8=8645
%term DIVU4=4550 DIVU8=8646
%term MULF4=4561 MULF8=8657
%term MULI4=4565 MULI8=8661
%term MULU4=4566 MULU8=8662
%term EQF4=4577 EQF8=8673
%term EQI4=4581 EQI8=8677
%term EQU4=4582 EQU8=8678
%term GEF4=4593 GEF8=8689
%term GEI4=4597 GEI8=8693
%term GEU4=4598 GEU8=8694
%term GTF4=4609 GTF8=8705
%term GTI4=4613 GTI8=8709
%term GTU4=4614 GTU8=8710
%term LEF4=4625 LEF8=8721
%term LEI4=4629 LEI8=8725
%term LEU4=4630 LEU8=8726
%term LTF4=4641 LTF8=8737
%term LTI4=4645 LTI8=8741
%term LTU4=4646 LTU8=8742
%term NEF4=4657 NEF8=8753
%term NEI4=4661 NEI8=8757
%term NEU4=4662 NEU8=8758
%term JUMPV=584
%term LABELV=600
%%
/* Because MicroVM is so strongly typed, it makes sense to build the grammar around
 *  the types.
 */
/* Assumption:
 *  we run through the tree placing a target local SSA variable for each node
 *  in p->syms[2]->x.name (not including the local SSA prefix, %).
 *  Since we want to choose target names that won't conflict, integers as
 *  strings are probably the best bet.
 */
/* Since a string of digits is a perfectly valid variable name in MicroVM,
 *  integer constants only need to be prepended with @ to make a global:
 * If the constant 42 appears in the dag, then we would emit at the top-level:
 *
 *  .typedef @long = int<64>
 *  .const @42_long <@long> = 42
 *
 * And an expression 42 + 42 would generate:
 *
 *  ... = ADD<@long> @42_long @42_long
 * Mangling floats is a little more involved, because the .
 *  is interpreted specially in MicroVM, though...
 */
anyvar:		float_var
anyvar:		double_var
anyvar:		char_var
anyvar:		short_var
anyvar:		int_var
anyvar:		long_var
anyvar:		ptr

float_var:	CNSTF4			"// Float constant %0"
double_var:	CNSTF8			"// Double constant %0"
char_var:	CNSTI1			"@%0_char"
char_var:	CNSTU1			"@%0_uchar"
short_var:	CNSTI2			"@%0_short"
short_var:	CNSTU2			"@%0_ushort"
int_var:	CNSTI4			"@%0_int"
int_var:	CNSTU4			"@%0_uint"
long_var:	CNSTI8			"@%0_long"
long_var:	CNSTU8			"@%0_ulong"
/*  (pointers for now may as well be iref<void>	*/
ptr:		CNSTP8			"// constant pointer unimplemented\n"
/* ARG* (arguments for call [in caller]) is unimplemented */
stmt:		ARGB(INDIRB(ptr))	"// structure arguments unimplemented\n"
stmt:		ARGF4(float_var)	"// float arguments unimplemented\n"
stmt:		ARGF8(double_var)	"// double arguments unimplemented\n"
stmt:		ARGI4(int_var)		"// int arguments unimplemented\n"
stmt:		ARGI8(long_var)		"// long arguments unimplemented\n"
stmt:		ARGP8(ptr)			"// pointer arguments unimplemented\n"
stmt:		ARGU4(int_var)		"// int arguments unimplemented\n"
stmt:		ARGU8(long_var)		"// long arguments unimplemented\n"
/* For ASGN* (assignment), the left child is an iref and the right child is
 *  the value to save.  Because the iref is to void, we need to cast it, so
 *  this needs to have a temporary local SSA variable in syms[2]->x.name (as a string)
 */
stmt:		ASGNB(ptr, INDIRB(ptr))	"// assignment to structure unimplemented\n"
stmt:		ASGNF4(ptr, float_var)	"%%%c = REFCAST <@_ptr_void @_ptr_float> %0\nSTORE <@float> %%%c %1\n"
stmt:		ASGNF8(ptr, double_var)	"%%%c = REFCAST <@_ptr_void @_ptr_double> %0\nSTORE <@double> %%%c %1\n"
stmt:		ASGNI1(ptr, char_var)	"%%%c = REFCAST <@_ptr_void @_ptr_char> %0\nSTORE <@char> %%%c %1\n"
stmt:		ASGNU1(ptr, char_var)	"%%%c = REFCAST <@_ptr_void @_ptr_char> %0\nSTORE <@char> %%%c %1\n"
stmt:		ASGNI2(ptr, short_var)	"%%%c = REFCAST <@_ptr_void @_ptr_short> %0\nSTORE <@short> %%%c %1\n"
stmt:		ASGNU2(ptr, short_var)	"%%%c = REFCAST <@_ptr_void @_ptr_short> %0\nSTORE <@short> %%%c %1\n"
stmt:		ASGNI4(ptr, int_var)	"%%%c = REFCAST <@_ptr_void @_ptr_int> %0\nSTORE <@int> %%%c %1\n"
stmt:		ASGNU4(ptr, int_var)	"%%%c = REFCAST <@_ptr_void @_ptr_int> %0\nSTORE <@int> %%%c %1\n"
stmt:		ASGNI8(ptr, long_var)	"%%%c = REFCAST <@_ptr_void @_ptr_long> %0\nSTORE <@long> %%%c %1\n"
stmt:		ASGNU8(ptr, long_var)	"%%%c = REFCAST <@_ptr_void @_ptr_long> %0\nSTORE <@long> %%%c %1\n"
stmt:		ASGNP8(ptr, ptr)		"%%%c = REFCAST <@_ptr_void @_ptr_ptr_void> %0\nSTORE <@ptr_void> %%%c %1\n"
/* INDIRBs have already been taken care of */
float_var:	INDIRF4(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_float> %0\n%%%c = LOAD <@float> %%%c_0\n"
double_var:	INDIRF8(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_double> %0\n%%%c = LOAD <@double> %%%c_0\n"
char_var:	INDIRI1(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_char> %0\n%%%c = LOAD <@char> %%%c_0\n"
char_var:	INDIRU1(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_char> %0\n%%%c = LOAD <@char> %%%c_0\n"
short_var:	INDIRI2(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_short> %0\n%%%c = LOAD <@short> %%%c_0\n"
short_var:	INDIRU2(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_short> %0\n%%%c = LOAD <@short> %%%c_0\n"
int_var:	INDIRI4(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_int> %0\n%%%c = LOAD <@int> %%%c_0\n"
int_var:	INDIRU4(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_int> %0\n%%%c = LOAD <@int> %%%c_0\n"
long_var:	INDIRI8(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_long> %0\n%%%c = LOAD <@long> %%%c_0\n"
long_var:	INDIRU8(ptr)			"%%%c_0 = REFCAST <@_ptr_void @_ptr_long> %0\n%%%c = LOAD <@long> %%%c_0\n"
ptr:		INDIRP8(ptr)			"%%%c_0 = REFCASt <@_ptr_void @_ptr_ptr_void> %0\n%%%c = LOAD <@ptr_void> %%%c_0\n"

float_var:	CVFF4(double_var)		"%%%c = FPTRUNC <@double @float> %0\n"
double_var:	CVFF8(float_var)		"%%%c = FPEXT <@float @double> %0\n"
int_var:	CVFI4(double_var)		"%%%c = FPTOSI <@double @int> %0\n"
int_var:	CVFI4(float_var)		"%%%c = FPTOSI <@float @int> %0\n"
long_var:	CVFI8(double_var)		"%%%c = FPTOSI <@double @long> %0\n"
long_var:	CVFI8(float_var)		"%%%c = FPTOSI <@float @long> %0\n"
float_var:	CVIF4(char_var)			"%%%c = SITOFP <@char @float> %0\n"
float_var:	CVIF4(short_var)		"%%%c = SITOFP <@short @float> %0\n"
float_var:	CVIF4(int_var)			"%%%c = SITOFP <@int @float> %0\n"
float_var:	CVIF4(long_var)			"%%%c = SITOFP <@long @float> %0\n"
double_var:	CVIF8(char_var)			"%%%c = SITOFP <@char @double> %0\n"
double_var:	CVIF8(short_var)		"%%%c = SITOFP <@short @double> %0\n"
double_var:	CVIF8(int_var)			"%%%c = SITOFP <@int @double> %0\n"
double_var:	CVIF8(long_var)			"%%%c = SITOFP <@long @double> %0\n"
char_var:	CVII1(short_var)		"%%%c = TRUNC <@short @char> %0\n"
char_var:	CVII1(int_var)			"%%%c = TRUNC <@int @char> %0\n"
char_var:	CVII1(long_var)			"%%%c = TRUNC <@long @char> %0\n"
short_var:	CVII2(char_var)			"%%%c = SEXT <@char @short> %0\n"
short_var:	CVII2(int_var)			"%%%c = TRUNC <@int @short> %0\n"
short_var:	CVII2(long_var)			"%%%c = TRUNC <@long @short> %0\n"
int_var:	CVII4(char_var)			"%%%c = SEXT <@char @int> %0\n"
int_var:	CVII4(short_var)		"%%%c = SEXT <@short @int> %0\n"
int_var:	CVII4(long_var)			"%%%c = TRUNC <@long @int> %0\n"
long_var:	CVII8(char_var)			"%%%c = SEXT <@char @long> %0\n"
long_var:	CVII8(short_var)		"%%%c = SEXT <@short @long> %0\n"
long_var:	CVII8(int_var)			"%%%c = SEXT <@int @long> %0\n"
char_var:	CVIU1(char_var)			"%%%c = %0\n"
char_var:	CVIU1(short_var)		"%%%c = TRUNC <@short @char> %0\n"
char_var:	CVIU1(int_var)			"%%%c = TRUNC <@int @char> %0\n"
char_var:	CVIU1(long_var)			"%%%c = TRUNC <@long @char> %0\n"
short_var:	CVIU2(char_var)			"%%%c = ZEXT <@char @short> %0\n"
short_var:	CVIU2(short_var)		"%%%c = %0\n"
short_var:	CVIU2(int_var)			"%%%c = TRUNC <@int @short> %0\n"
short_var:	CVIU2(long_var)			"%%%c = TRUNC <@long @short> %0\n"
int_var:	CVIU4(char_var)			"%%%c = ZEXT <@char @int> %0\n"
int_var:	CVIU4(short_var)		"%%%c = ZEXT <@short @int> %0\n"
int_var:	CVIU4(int_var)			"%%%c = %0\n"
int_var:	CVIU4(long_var)			"%%%c = TRUNC <@long @int> %0\n"
long_var:	CVIU8(char_var)			"%%%c = ZEXT <@char @long> %0\n"
long_var:	CVIU8(short_var)		"%%%c = ZEXT <@short @long> %0\n"
long_var:	CVIU8(int_var)			"%%%c = ZEXT <@int @long> %0\n"
long_var:	CVIU8(long_var)			"%%%c = %0\n"
long_var:	CVPU8(ptr)				"// Pointer to integer conversion not supported\n"
char_var:	CVUI1(char_var)			"%%%c = %0\n"
char_var:	CVUI1(short_var)		"%%%c = TRUNC <@short @char> %0\n"
char_var:	CVUI1(int_var)			"%%%c = TRUNC <@int @char> %0\n"
char_var:	CVUI1(long_var)			"%%%c = TRUNC <@long @char> %0\n"
short_var:	CVUI2(char_var)			"%%%c = SEXT <@char @short> %0\n"
short_var:	CVUI2(short_var)		"%%%c = %0\n"
short_var:	CVUI2(int_var)			"%%%c = TRUNC <@int @short> %0\n"
short_var:	CVUI2(long_var)			"%%%c = TRUNC <@long @short> %0\n"
int_var:	CVUI4(char_var)			"%%%c = SEXT <@char @int> %0\n"
int_var:	CVUI4(short_var)		"%%%c = SEXT <@short @int> %0\n"
int_var:	CVUI4(int_var)			"%%%c = %0\n"
int_var:	CVUI4(long_var)			"%%%c = TRUNC <@long @int> %0\n"
long_var:	CVUI8(char_var)			"%%%c = SEXT <@char @long> %0\n"
long_var:	CVUI8(short_var)		"%%%c = SEXT <@short @long> %0\n"
long_var:	CVUI8(int_var)			"%%%c = SEXT <@int @long> %0\n"
long_var:	CVUI8(int_var)			"%%%c = %0\n"
ptr:		CVUP8(char_var)			"// Integer to pointer conversion not supported\n"
ptr:		CVUP8(short_var)		"// Integer to pointer conversion not supported\n"
ptr:		CVUP8(int_var)			"// Integer to pointer conversion not supported\n"
ptr:		CVUP8(long_var)			"// Integer to pointer conversion not supported\n"
char_var:	CVUU1(short_var)		"%%%c = TRUNC <@short @char> %0\n"
char_var:	CVUU1(int_var)			"%%%c = TRUNC <@int @char> %0\n"
char_var:	CVUU1(long_var)			"%%%c = TRUNC <@long @char> %0\n"
short_var:	CVUU2(char_var)			"%%%c = ZEXT <@char @short> %0\n"
short_var:	CVUU2(int_var)			"%%%c = TRUNC <@int @short> %0\n"
short_var:	CVUU2(long_var)			"%%%c = TRUNC <@long @short> %0\n"
int_var:	CVUU4(char_var)			"%%%c = ZEXT <@char @int> %0\n"
int_var:	CVUU4(short_var)		"%%%c = ZEXT <@short @int> %0\n"
int_var:	CVUU4(long_var)			"%%%c = TRUNC <@long @int> %0\n"
long_var:	CVUU8(char_var)			"%%%c = ZEXT <@char @long> %0\n"
long_var:	CVUU8(short_var)		"%%%c = ZEXT <@short @long> %0\n"
long_var:	CVUU8(int_var)			"%%%c = ZEXT <@int @long> %0\n"

float_var:	NEGF4(float_var)		"// Negate float value %0"
double_var:	NEGF4(double_var)		"// Negate double value %0"
int_var:	NEGI4(int_var)			"%%%c = SUB <@int> @0_int %0\n"
long_var:	NEGI8(long_var)			"%%%c = SUB <@long> @0_long %0\n"
/* CALL* is really hazy... (CALLB even more so!) */
float_var:	CALLF4(ptr)				"// Call (float) unimplemented\n"
double_var:	CALLF8(ptr)				"// Call (double) unimplemented\n"
int_var:	CALLI4(ptr)				"// Call (int) unimplemented\n"
long_var:	CALLI8(ptr)				"// Call (long) unimplemented\n"
ptr:		CALLP8(ptr)				"// Call (pointer) unimplemented\n"
int_var:	CALLU4(ptr)				"// Call (uint) unimplemented\n"
long_var:	CALLU8(ptr)				"// Call (ulong) unimplemented\n"
stmt:		CALLV(ptr)				"// Call (void) unimplemented\n"

stmt:		RETF4(float_var)		"RET <@float> %0\n"
stmt:		RETF8(double_var)		"RET <@double> %0\n"
stmt:		RETI4(int_var)			"RET <@int> %0\n"
stmt:		RETI8(long_var)			"RET <@long> %0\n"
stmt:		RETP8(ptr)				"RET <@_ptr_void> %0\n"
stmt:		RETU4(int_var)			"RET <@int> %0\n"
stmt:		RETU8(long_var)			"RET <@long> %0\n"
stmt:		RETV(anyvar)			"RETVOID\n"

/* For now, what makes sense is to have every variable be allocated (on the
 *  stack with ALLOCA for locals and on the heap with NEW (and then GETIREF)
 *  for globals.  Because LCC pointers are all effectively void pointers, and,
 *  as it stands, we can't annotate the tree with types, variables are iref<void>.
 *
 *   // local variable
 *   %0foo_0 = ALLOCA <@int> // name chosen so as not to conflict with anything
 *                           //  in C
 *   %foo = REFCAST <@_ptr_int @_ptr_void>
 *   
 *   // global variable; code is in some sort of init function
 *   %0bar_0 = NEW <@int>
 *   %0bar_1 = GETIREF <@int> %0bar_0
 *   @bar = REFCAST <@_ptr_int @_ptr_void>
 */
ptr:		ADDRGP8					"@%a"
ptr:		ADDRLP8					"%%%a"
/* Argument handling is currently somewhat unclear... this assumes that we
 *  use MicroVM for argument handling
 */
ptr:		ADDRFP8					"%%%a"

float_var:	ADDF4(float_var, float_var)	"%%%c = FADD <@float> %0 %1\n"
double_var:	ADDF8(double_var, double_var)	"%%%c = FADD <@double> %0 %1\n"
int_var:	ADDI4(int_var, int_var)		"%%%c = ADD <@int> %0 %1\n"
long_var:	ADDI8(long_var, long_var)	"%%%c = ADD <@long> %0 %1\n"
ptr:		ADDP8(ptr, long_var)		"%%%c_0 = REFCAST <@_ptr_void @_ptr_char> %0\n%%%c_1 = SHIFTIREF <@char @long> %%%c_0 %1\n%%%c = REFCAST <@_ptr_char @_ptr_void> %%%c_1\n"
int_var:	ADDU4(int_var, int_var)		"%%%c = ADD <@int> %0 %1\n"
long_var:	ADDU8(long_var, long_var)	"%%%c = ADD <@long> %0 %1\n"

float_var:	SUBF4(float_var, float_var)	"%%%c = FSUB <@float> %0 %1\n"
double_var:	SUBF8(double_var, double_var)	"%%%c = FSUB <@double> %0 %1\n"
int_var:	SUBI4(int_var, int_var)		"%%%c = SUB <@int> %0 %1\n"
long_var:	SUBI8(long_var, long_var)	"%%%c = SUB <@long> %0 %1\n"
ptr:		SUBP8(ptr, long_var)		"%%%c_0 = REFCAST <@_ptr_void @_ptr_char> %0\n%%%c_1 = SUB <@long> @0_long %1\n%%%c_2 = SHIFTIREF <@char @long> %%%c_0 %%%c_1\n%%%c = REFCAST <@_ptr_char @_ptr_void> %%%c_2\n"
int_var:	SUBU4(int_var, int_var)		"%%%c = SUB <@int> %0 %1\n"
long_var:	SUBU8(long_var, long_var)	"%%%c = SUB <@long> %0 %1\n"

int_var:	LSHI4(int_var, int_var)		"%%%c = SHL <@int> %0 %1\n"
long_var:	LSHI8(long_var, long_var)	"%%%c = SHL <@long> %0 %1\n"
int_var:	LSHU4(int_var, int_var)		"%%%c = SHL <@int> %0 %1\n"
long_var:	LSHU8(long_var, long_var)	"%%%c = SHL <@long> %0 %1\n"

int_var:	MODI4(int_var, int_var)		"%%%c = SREM <@int> %0 %1\n"
long_var:	MODI8(long_var, long_var)	"%%%c = SREM <@long> %0 %1\n"
int_var:	MODU4(int_var, int_var)		"%%%c = UREM <@int> %0 %1\n"
long_var:	MODU8(long_var, long_var)	"%%%c = UREM <@int> %0 %1\n"

int_var:	RSHI4(int_var, int_var)		"%%%c = ASHR <@int> %0 %1\n"
long_var:	RSHI8(long_var, long_var)	"%%%c = ASHR <@long> %0 %1\n"
int_var:	RSHU4(int_var, int_var)		"%%%c = LSHR <@int> %0 %1\n"
long_var:	RSHU8(long_var, long_var)	"%%%c = LSHR <@long> %0 %1\n"

int_var:	BANDI4(int_var, int_var)	"%%%c = AND <@int> %0 %1\n"
long_var:	BANDI8(long_var, long_var)	"%%%c = AND <@long> %0 %1\n"
int_var:	BANDU4(int_var, int_var)	"%%%c = AND <@int> %0 %1\n"
long_var:	BANDU8(long_var, long_var)	"%%%c = AND <@long> %0 %1\n"

/* Surprisingly, bitwise complement is not a MicroVM instruction.  Easiest is
 *  is probably to XOR with -1 in 2's complement.  This requires that emitted
 *  code include:
 *
 *  .const @1_neg_int <@int> = -1
 *  .const @1_net_long <@long> = -1
 */
int_var:	BCOMI4(int_var)				"%%%c = XOR <@int> %0 @1_neg_int\n"
long_var:	BCOMI8(long_var)			"%%%c = XOR <@long> %0 @1_neg_long\n"
int_var:	BCOMU4(int_var)				"%%%c = XOR <@int> %0 @1_neg_int\n"
long_var:	BCOMU8(long_var)			"%%%c = XOR <@long> %0 @1_neg_long\n"

int_var:	BORI4(int_var)				"%%%c = OR <@int> %0 %1\n"
long_var:	BORI8(long_var)				"%%%c = OR <@long> %0 %1\n"
int_var:	BORU4(int_var)				"%%%c = OR <@int> %0 %1\n"
long_var:	BORU8(long_var)				"%%%c = OR <@long> %0 %1\n"

int_var:	BXORI4(int_var)				"%%%c = XOR <@int> %0 %1\n"
long_var:	BXORI8(long_var)			"%%%c = XOR <@int> %0 %1\n"

float_var:	DIVF4(float_var, float_var)	"%%%c = FDIV <@float> %0 %1\n"
double_var:	DIVF8(double_var, double_var)	"%%%c = FDIV <@double> %0 %1\n"
int_var:	DIVI4(int_var, int_var)		"%%%c = SDIV <@int> %0 %1\n"
long_var:	DIVI8(long_var, long_var)	"%%%c = SDIV <@long> %0 %1\n"
int_var:	DIVU4(int_var, int_var)		"%%%c = UDIV <@int> %0 %1\n"
long_var:	DIVU8(long_var, long_var)	"%%%c = UDIV <@long> %0 %1\n"

float_var:	MULF4(float_var, float_var)	"%%%c = FMUL <@float> %0 %1\n"
double_var:	MULF8(double_var, double_var)	"%%%c = FMUL <@double> %0 %1\n"
int_var:	MULI4(int_var, int_var)		"%%%c = MUL <@int> %0 %1\n"
long_var:	MULI8(long_var, long_var)	"%%%c = MUL <@long> %0 %1\n"
int_var:	MULU4(int_var, int_var)		"%%%c = MUL <@int> %0 %1\n"
long_var:	MULU8(long_var, long_var)	"%%%c = MUL <@long> %0 %1\n"

/* Comparisons include the label to jump to if true.  MicroVM's BRANCH2
 *  instruction, though, requires a basic block to jump to if false.  We will
 *  probably need to manipulate the trees in some fashion.
 * The template is:
 *  %result_temp = op <@type> %0 %1
 *  BRANCH2 %result_temp %%%a %alternative
 * It appears that we can probably store the alternative label as syms[1].
 */
stmt:		EQF4(float_var, float_var)	"%%%c = FOEQ <@float> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		EQF8(double_var, double_var)	"%%%c = FOEQ <@float> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		EQI4(int_var, int_var)		"%%%c = EQ <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		EQI8(long_var, long_var)	"%%%c = EQ <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		EQU4(int_var, int_var)		"%%%c = EQ <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		EQU8(long_var, long_var)	"%%%c = EQ <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GEF4(float_var, float_var)	"%%%c = FOGE <@float> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GEF8(double_var, double_var)	"%%%c = FOGE <@double> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GEI4(int_var, int_var)		"%%%c = SGE <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GEI8(long_var, long_var)	"%%%c = SGE <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GEU4(int_var, int_var)		"%%%c = UGE <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GEU8(long_var, long_var)	"%%%c = UGE <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GTF4(float_var, float_var)	"%%%c = FOGT <@float> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GTF8(double_var, double_var)	"%%%c = FOGT <@double> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GTI4(int_var, int_var)		"%%%c = SGT <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GTI8(long_var, long_var)	"%%%c = SGT <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GTU4(int_var, int_var)		"%%%c = UGT <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		GTU8(long_var, long_var)	"%%%c = UGT <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LEF4(float_var, float_var)	"%%%c = FOLE <@float> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LEF8(double_var, double_var)	"%%%c = FOLE <@double> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LEI4(int_var, int_var)		"%%%c = SLE <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LEI8(long_var, long_var)	"%%%c = SLE <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LEU4(int_var, int_var)		"%%%c = ULE <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LEU8(long_var, long_var)	"%%%c = ULE <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LTF4(float_var, float_var)	"%%%c = FOLT <@float> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LTF8(double_var, double_var)	"%%%c = FOLT <@double> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LTI4(int_var, int_var)		"%%%c = SLT <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LTI8(long_var, long_var)	"%%%c = SLT <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LTU4(int_var, int_var)		"%%%c = ULT <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		LTU8(long_var, long_var)	"%%%c = ULT <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		NEF4(float_var, float_var)	"%%%c = FONE <@float> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		NEF8(double_var, double_var)	"%%%c = FONE <@double> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		NEI4(int_var, int_var)		"%%%c = NE <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		NEI8(long_var, long_var)	"%%%c = NE <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		NEU4(int_var, int_var)		"%%%c = NE <@int> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		NEU8(long_var, long_var)	"%%%c = NE <@long> %0 %1\nBRANCH2 %%%c %%%a %%%b\n"
stmt:		JUMPV(ptr)					"BRANCH %0\n"
stmt:		LABELV()					"%%%a:\n"
%%
static void progbeg(int argc, char **argv)
{
	global_osymtable = osymtable_create(PERM);
}

static void function(Symbol f, Symbol caller[], Symbol callee[], int ncalls)
{
	int i;
	char *sig_id, *version_id;
	Symbol arg;

	typedefs = NULL;
	func_osymtable = osymtable_create(FUNC);

	if (f->type.u.f.oldstyle) {
		print("// Pre-ANSI C function omitted\n");
		print("// There are Ph.D.'s who are younger than ANSI C.\n");
		print("// REWRITE YOUR CODE!!!!!!!\n\n");
		return;
	}

	gencode(caller, callee);

	// Print typedefs.
	while (typedefs.link != NULL) {
		print(".typedef @%s = %s\n\n", typedefs.name, typedefs.type);
		typedefs = typedefs.link;
	}

	// Print function signature.
	sig_id = define_function_signature(f);

	// Print function definitions.
	version_id = allocate(strlen(f->name) + 4, PERM);
	strcpy(version_id, f->name);
	strcat(version_id, "_v1");
	print(".funcdef @%s VERSION @%s <@%s> (",
			unique_symbol(f->name, NULL, 0),
			unique_symbol(version_id, NULL, 0),
			sig_id);
	for (i = 0; (arg = callee[i]) != NULL; i++) {
		if (i > 0) print(" ");
		print("%%%s", arg->name);
	}
	print(") {\n")
	emitcode();
	print("}\n\n");
}

static int is_type_defined(Type t)
{
	List l = defined_types;
	while (l != NULL) {
		if (l.x == t) return 1;
		l = l.link;
	}
	return 0;
}

static void define_type(Type t)
{
	char *sym;
	char *subsym;
	List new_list_node;
	Type largest;
	Field f;
	if (is_type_defined(t)) return;
	switch (t->op) {
		case VOID:
			sym = unique_symbol("void", NULL, 1);
			print(".typedef @%s = void\n\n", sym);
			break;
		case CHAR:
		case INT:
		case UNSIGNED:
		case SHORT:
		case LONG:
		case ENUM:
			sym = unique_symbol(t->u.sym->name, NULL, 1);
			print(".typedef @%s = int<%d>\n\n", sym, t->size);
			break;
		case FLOAT:
			sym = unique_symbol("float", NULL, 1);
			print(".typedef @%s = float\n\n", sym);
			break;
		case DOUBLE:
			sym = unique_symbol("double", NULL, 1);
			print(".typedef @%s = double\n\n", sym);
			break;
		case ARRAY:
			define_type(t->type);
			subsym = t->type->x->mvm_symbol;
			sym = (char*)allocate(strlen(subsym) + 7, PERM);
			sprintf(sym, "array_%s", subsym);
			sym = unique_symbol(sym, NULL, false);
			print(".typedef @%s = array<@%s %d>\n\n",
					sym, subsym, t->size / t->type->size);
			break;
		case STRUCT:
			// TODO: Handle bit fields.
			sym = unique_symbol(t->u.sym->name, NULL, 1);
			print(".typedef @%s = struct<", sym);
			for (f = t->u.sym->u.s.flist; f != NULL; f = f->link) {
				define_type(f->type);
				print("@%s", f->type->x->mvm_symbol);
				if (f->link != NULL) print(" ");
			}
			print(">\n\n");
			break;
		case UNION:
			// Pick the largest type in the union. This is not an ideal way to
			// represent unions, but uVM doesn't give us many other options.
			// TODO: Handle bit fields.
			largest = NULL;
			for (f = t->u.sym->u.s.flist; f != NULL; f = f->link) {
				define_type(f->type);
				if (largest == NULL || f->type->size > largest->size) {
					largest = f->type;
				}
			}
			sym = unique_symbol(t->u.sym->name, NULL, 1);
			print("// Union: %s\n", sym);
			print(".typedef @%s = @%s\n\n", sym, largest->x->mvm_symbol);
			break;
		case POINTER:
			define_type(t->type);
			subsym = t->type->x->mvm_symbol;
			sym = (char*)allocate(strlen(subsym) + 5, PERM);
			strcpy(sym, "ptr_");
			strcat(sym, subsym);
			sym = unique_symbol(sym, NULL, false);
			print(".typedef @%s = uref\n\n", sym);
			break;
		case FUNCTION:
			// TODO: functions
			break;
		default: // Assume CONST, VOLATILE, or CONST+VOLATILE.
			define_type(t->type);
			sym = t->type->x->mvm_symbol;
			break;
	}
	t->x->mvm_symbol = sym;
	new_list_node = allocate(sizeof(struct list), PERM);
	new_list_node.x = t;
	new_list_node.link = defined_types;
	defined_types = new_list_node;
}

static char *define_function_signature(Symbol f)
{
	int i;
	char *sig_id;
	sig_id = allocate(strlen(f->name) + 5, PERM);
	strcpy(sig_id, f->name);
	strcat(sig_id, "_sig");
	sig_id = unique_symbol(sig_id, NULL, 0);
	print(".funcsig @%s = @%s (", sig_id, f->type.type->x->mvm_symbol);
	for (i = 0; f->type.u.f.proto[i] != NULL; i++) {
		if (i > 0) print(" ");
		print("@%s", f->type.u.f.proto[i]->x->mvm_symbol);
	}
	print(")\n\n");
	return sig_id;
}

static void walk_type_tree(Node tree, TypeVisitor visitor)
{
	switch (tree->op & ~0xf) {
		case ADDRF:
		case ADDRG:
		case ADDRL:
		case CNST:
			visitor(tree->syms[0]->type);
			break;
		case BCOM:
		case CVC:
		case CVD:
		case CVF:
		case CVI:
		case CVP:
		case CVS:
		case CVU:
		case INDIR:
		case NEG:
			walk_type_tree(tree->kids[0]);
			break;
		case ADD:
		case BAND:
		case BOR:
		case BXOR:
		case DIV:
		case LSH:
		case MOD:
		case MUL:
		case RSH:
		case SUB:
			walk_type_tree(tree->kids[0]);
			walk_type_tree(tree->kids[1]);
			break;
		case ASGN:
			visitor(tree->syms[0]->type);
			visitor(tree->syms[1]->type);
			walk_type_tree(tree->kids[0]);
			walk_type_tree(tree->kids[1]);
			break;
		case EQ:
		case GE:
		case GT:
		case LE:
		case LT:
		case NE:
			walk_type_tree(tree->kids[0]);
			walk_type_tree(tree->kids[1]);
			break;
		case ARG:
			visitor(tree->syms[0]->type);
			visitor(tree->syms[1]->type);
			walk_type_tree(tree->kids[0]);
			break;
		case CALL:
			visitor(tree->syms[0]->type);
			walk_type_tree(tree->kids[0]);
			if (tree->kids[1] != NULL) walk_type_tree(tree->kids[1]);
			break;
		case RET:
		case JUMP:
			walk_type_tree(tree->kids[0]);
			break;
		// Otherwise, do nothing.
	}
}

static Node gen_with_typedefs(Node forest)
{
	walk_type_tree(forest, define_type);
	return gen(forest);
}

static char *unique_symbol(char *sym, OutputSymbolTable local_table, int alloc)
{
	char[256] tempsym;
	char *newsym;
	int symlen = 0;
	while (osymtable_check(global_osymtable, sym) ||
			(local_table != NULL && osymtable_check(local_table, sym))) {
		symlen = symlen > 0 ? symlen + 1 : strlen(sym);
		if (symlen > 254) break; // Prevent buffer overflows.
		strcpy(tempsym, sym);
		tempsym[symlen] = '_';
		tempsym[symlen+1] = '\0';
		sym = tempsym;
		alloc = 1;
	}
	if (alloc) {
		newsym = allocate(strlen(sym) + 1, local_table == NULL ? PERM : FUNC);
		strcpy(newsym, sym);
		sym = newsym;
	}
	osymtable_put(local_table == NULL ? global_osymtable : local_table, sym);
	return sym;
}

static OutputSymbolTable osymtable_create(int arena)
{
	int i;
	OutputSymbolTable table = allocate(sizeof(List)*OSYMTABLE_BUCKETS, arena);
	for (i = 0; i < OSYMTABLE_BUCKETS; i++) table[i] = NULL;
	return table;
}

static void osymtable_put(OutputSymbolTable table, char *sym)
{
	int bucket = osymtable_bucket(sym);
	List node = allocate(sizeof(struct list), PERM);
	node.x = (void*)sym;
	node.link = table[bucket];
	table[bucket] = node;
}

static int osymtable_check(OutputSymbolTable table, char* sym)
{
	List node = table[osymtable_bucket(sym)];
	while (node != NULL) {
		if (strcmp(sym, (char*)node.x) == 0) return 1;
		node = node.link;
	}
	return 0;
}

static int osymtable_bucket(char *str)
{
	// Really dumb hash function.
	int i, n = 0;
	for (i = 0; str[i] > 0; i++) {
		n = (n + str[i]) % OSYMTABLE_BUCKETS;
	}
	return n;
}

/* vim: set ft=c ts=4 sw=4 noexpandtab: */
